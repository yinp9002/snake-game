<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <!-- Tailwind CSS v3 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome -->
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <!-- GSAP for animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4ade80',
                        secondary: '#f43f5e',
                        dark: '#0f172a',
                        light: '#f8fafc',
                        accent: '#8b5cf6'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                    animation: {
                        'pulse-fast': 'pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .text-shadow {
                text-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .text-shadow-lg {
                text-shadow: 0 4px 8px rgba(0,0,0,0.2);
            }
            .grid-pattern {
                background-image: radial-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px);
                background-size: 20px 20px;
            }
            .snake-head {
                border-radius: 4px;
            }
            .snake-body {
                border-radius: 2px;
            }
            .food {
                border-radius: 50%;
                animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
            }
            .game-overlay {
                backdrop-filter: blur(4px);
                -webkit-backdrop-filter: blur(4px);
            }
            .btn-3d {
                position: relative;
                transform-style: preserve-3d;
                transition: transform 0.2s;
            }
            .btn-3d:before {
                content: '';
                position: absolute;
                width: 100%;
                height: 100%;
                left: 0;
                bottom: -4px;
                background-color: rgba(0,0,0,0.2);
                transform: translateZ(-1px);
                border-radius: inherit;
            }
            .btn-3d:active {
                transform: translateY(2px);
            }
            .btn-3d:active:before {
                bottom: -2px;
            }
            .trail {
                position: absolute;
                background-color: rgba(74, 222, 128, 0.3);
                border-radius: 50%;
                pointer-events: none;
                z-index: 10;
            }
        }
    </style>
</head>
<body class="bg-dark text-light min-h-screen flex flex-col items-center justify-center p-4 overflow-x-hidden">
    <!-- Game Container -->
    <div class="max-w-md w-full mx-auto flex flex-col items-center">
        <!-- Game Title -->
        <h1 class="text-[clamp(2rem,5vw,3rem)] font-bold text-primary mb-4 text-center text-shadow-lg">Snake Game</h1>
        
        <!-- Score Display -->
        <div class="w-full flex justify-between items-center mb-4 px-2">
            <div class="bg-gray-800 rounded-lg px-4 py-2 shadow-lg">
                <span class="text-gray-400 text-sm">Score</span>
                <div id="score" class="text-2xl font-bold text-primary">0</div>
            </div>
            <div class="bg-gray-800 rounded-lg px-4 py-2 shadow-lg">
                <span class="text-gray-400 text-sm">High Score</span>
                <div id="highScore" class="text-2xl font-bold text-accent">0</div>
            </div>
        </div>
        
        <!-- Game Board Container -->
        <div class="relative w-full aspect-square max-w-md mx-auto bg-gray-900 rounded-xl overflow-hidden shadow-2xl grid-pattern">
            <!-- Game Canvas -->
            <canvas id="gameCanvas" class="w-full h-full"></canvas>
            
            <!-- Game Overlay (Start Screen) -->
            <div id="startScreen" class="absolute inset-0 flex flex-col items-center justify-center game-overlay bg-dark/70 z-20">
                <h2 class="text-3xl font-bold mb-8 text-shadow">Snake Game</h2>
                <div class="flex flex-col gap-4 w-64">
                    <button id="startBtn" class="btn-3d bg-primary hover:bg-primary/90 text-dark font-bold py-3 px-6 rounded-lg shadow-lg transition-all duration-200 flex items-center justify-center gap-2">
                        <i class="fa fa-play"></i> Start Game
                    </button>
                    <button id="difficultyBtn" class="btn-3d bg-gray-700 hover:bg-gray-600 text-light font-bold py-3 px-6 rounded-lg shadow-lg transition-all duration-200 flex items-center justify-center gap-2">
                        <i class="fa fa-sliders"></i> Difficulty: <span id="difficultyText">Medium</span>
                    </button>
                </div>
            </div>
            
            <!-- Game Over Overlay -->
            <div id="gameOverScreen" class="absolute inset-0 flex flex-col items-center justify-center game-overlay bg-dark/70 z-20 hidden">
                <h2 class="text-3xl font-bold mb-2 text-shadow">Game Over</h2>
                <p class="text-xl mb-2">Your Score: <span id="finalScore">0</span></p>
                <p id="newHighScore" class="text-accent font-bold mb-6 hidden">New High Score!</p>
                <div class="flex flex-col gap-4 w-64">
                    <button id="restartBtn" class="btn-3d bg-primary hover:bg-primary/90 text-dark font-bold py-3 px-6 rounded-lg shadow-lg transition-all duration-200 flex items-center justify-center gap-2">
                        <i class="fa fa-refresh"></i> Play Again
                    </button>
                    <button id="homeBtn" class="btn-3d bg-gray-700 hover:bg-gray-600 text-light font-bold py-3 px-6 rounded-lg shadow-lg transition-all duration-200 flex items-center justify-center gap-2">
                        <i class="fa fa-home"></i> Home
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Mobile Controls -->
        <div id="mobileControls" class="mt-6 grid grid-cols-3 gap-2 w-full max-w-xs mx-auto hidden">
            <div></div>
            <button id="upBtn" class="btn-3d bg-gray-700 hover:bg-gray-600 text-light font-bold py-3 rounded-lg shadow-lg transition-all duration-200">
                <i class="fa fa-arrow-up"></i>
            </button>
            <div></div>
            <button id="leftBtn" class="btn-3d bg-gray-700 hover:bg-gray-600 text-light font-bold py-3 rounded-lg shadow-lg transition-all duration-200">
                <i class="fa fa-arrow-left"></i>
            </button>
            <div></div>
            <button id="rightBtn" class="btn-3d bg-gray-700 hover:bg-gray-600 text-light font-bold py-3 rounded-lg shadow-lg transition-all duration-200">
                <i class="fa fa-arrow-right"></i>
            </button>
            <div></div>
            <button id="downBtn" class="btn-3d bg-gray-700 hover:bg-gray-600 text-light font-bold py-3 rounded-lg shadow-lg transition-all duration-200">
                <i class="fa fa-arrow-down"></i>
            </button>
            <div></div>
        </div>
        
        <!-- Game Instructions -->
        <div class="mt-6 text-center text-gray-400 text-sm">
            <p>Use arrow keys to control the snake</p>
            <p class="mt-1">Eat food to grow and avoid hitting walls or yourself</p>
        </div>
    </div>
    
    <!-- Trail Container -->
    <div id="trailContainer" class="fixed inset-0 pointer-events-none z-10"></div>
</body>
<script>
    // Game Variables
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const highScoreElement = document.getElementById('highScore');
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalScoreElement = document.getElementById('finalScore');
    const newHighScoreElement = document.getElementById('newHighScore');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const homeBtn = document.getElementById('homeBtn');
    const difficultyBtn = document.getElementById('difficultyBtn');
    const difficultyText = document.getElementById('difficultyText');
    const mobileControls = document.getElementById('mobileControls');
    const trailContainer = document.getElementById('trailContainer');
    
    // Game State
    let snake = [];
    let food = {};
    let gridSize = 20;
    let direction = 'right';
    let nextDirection = 'right';
    let score = 0;
    let highScore = localStorage.getItem('snakeHighScore') || 0;
    let gameSpeed = 150; // ms
    let gameInterval;
    let isGameRunning = false;
    let difficulty = 'medium'; // easy, medium, hard
    let trailEffect = true;
    
    // Set high score on load
    highScoreElement.textContent = highScore;
    
    // Set canvas size
    function resizeCanvas() {
        const container = canvas.parentElement;
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        gridSize = Math.floor(canvas.width / 20); // Adjust grid size based on canvas width
        
        // Show mobile controls on small screens
        if (window.innerWidth < 768) {
            mobileControls.classList.remove('hidden');
        } else {
            mobileControls.classList.add('hidden');
        }
    }
    
    // Initialize game
    function initGame() {
        // Reset snake
        const centerX = Math.floor(canvas.width / (2 * gridSize)) * gridSize;
        const centerY = Math.floor(canvas.height / (2 * gridSize)) * gridSize;
        
        snake = [
            { x: centerX, y: centerY },
            { x: centerX - gridSize, y: centerY },
            { x: centerX - gridSize * 2, y: centerY }
        ];
        
        direction = 'right';
        nextDirection = 'right';
        score = 0;
        scoreElement.textContent = score;
        
        // Generate first food
        generateFood();
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw initial state
        drawSnake();
        drawFood();
    }
    
    // Generate food at random position
    function generateFood() {
        let isFoodOnSnake;
        
        do {
            isFoodOnSnake = false;
            food = {
                x: Math.floor(Math.random() * (canvas.width / gridSize)) * gridSize,
                y: Math.floor(Math.random() * (canvas.height / gridSize)) * gridSize
            };
            
            // Check if food is on snake
            for (let segment of snake) {
                if (segment.x === food.x && segment.y === food.y) {
                    isFoodOnSnake = true;
                    break;
                }
            }
        } while (isFoodOnSnake);
    }
    
    // Draw snake
    function drawSnake() {
        // Draw head
        ctx.fillStyle = '#4ade80'; // primary color
        ctx.fillRect(snake[0].x, snake[0].y, gridSize, gridSize);
        
        // Draw eyes
        ctx.fillStyle = '#0f172a'; // dark color
        const eyeSize = gridSize / 5;
        
        // Position eyes based on direction
        if (direction === 'right') {
            ctx.fillRect(snake[0].x + gridSize - eyeSize * 2, snake[0].y + eyeSize, eyeSize, eyeSize);
            ctx.fillRect(snake[0].x + gridSize - eyeSize * 2, snake[0].y + gridSize - eyeSize * 2, eyeSize, eyeSize);
        } else if (direction === 'left') {
            ctx.fillRect(snake[0].x + eyeSize, snake[0].y + eyeSize, eyeSize, eyeSize);
            ctx.fillRect(snake[0].x + eyeSize, snake[0].y + gridSize - eyeSize * 2, eyeSize, eyeSize);
        } else if (direction === 'up') {
            ctx.fillRect(snake[0].x + eyeSize, snake[0].y + eyeSize, eyeSize, eyeSize);
            ctx.fillRect(snake[0].x + gridSize - eyeSize * 2, snake[0].y + eyeSize, eyeSize, eyeSize);
        } else if (direction === 'down') {
            ctx.fillRect(snake[0].x + eyeSize, snake[0].y + gridSize - eyeSize * 2, eyeSize, eyeSize);
            ctx.fillRect(snake[0].x + gridSize - eyeSize * 2, snake[0].y + gridSize - eyeSize * 2, eyeSize, eyeSize);
        }
        
        // Draw body with gradient effect
        for (let i = 1; i < snake.length; i++) {
            const segment = snake[i];
            const opacity = Math.max(0.3, 1 - (i / snake.length) * 0.7);
            
            // Create gradient based on position
            const gradient = ctx.createLinearGradient(segment.x, segment.y, segment.x + gridSize, segment.y + gridSize);
            gradient.addColorStop(0, `rgba(74, 222, 128, ${opacity})`); // primary color with opacity
            gradient.addColorStop(1, `rgba(139, 92, 246, ${opacity})`); // accent color with opacity
            
            ctx.fillStyle = gradient;
            ctx.fillRect(segment.x, segment.y, gridSize, gridSize);
        }
    }
    
    // Draw food
    function drawFood() {
        // Create gradient for food
        const gradient = ctx.createRadialGradient(
            food.x + gridSize / 2, food.y + gridSize / 2, 0,
            food.x + gridSize / 2, food.y + gridSize / 2, gridSize / 2
        );
        gradient.addColorStop(0, '#f43f5e'); // secondary color
        gradient.addColorStop(1, '#ef4444'); // slightly different shade
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(food.x + gridSize / 2, food.y + gridSize / 2, gridSize / 2, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Move snake
    function moveSnake() {
        // Create trail effect
        if (trailEffect && snake.length > 1) {
            createTrail(snake[snake.length - 1].x, snake[snake.length - 1].y);
        }
        
        // Save previous head position for growth logic
        const prevHead = { x: snake[0].x, y: snake[0].y };
        
        // Update direction
        direction = nextDirection;
        
        // Move head
        if (direction === 'right') {
            snake.unshift({ x: prevHead.x + gridSize, y: prevHead.y });
        } else if (direction === 'left') {
            snake.unshift({ x: prevHead.x - gridSize, y: prevHead.y });
        } else if (direction === 'up') {
            snake.unshift({ x: prevHead.x, y: prevHead.y - gridSize });
        } else if (direction === 'down') {
            snake.unshift({ x: prevHead.x, y: prevHead.y + gridSize });
        }
        
        // Check if snake ate food
        if (snake[0].x === food.x && snake[0].y === food.y) {
            // Increase score
            score += 10;
            scoreElement.textContent = score;
            
            // Generate new food
            generateFood();
            
            // Increase speed slightly
            updateGameSpeed();
            
            // Animate score
            gsap.fromTo(scoreElement, 
                { scale: 1.2, color: '#f43f5e' },
                { scale: 1, color: '#4ade80', duration: 0.3 }
            );
        } else {
            // Remove tail if didn't eat food
            snake.pop();
        }
        
        // Check for collisions
        if (checkCollision()) {
            gameOver();
            return;
        }
        
        // Clear canvas and redraw
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawSnake();
        drawFood();
    }
    
    // Check for collisions
    function checkCollision() {
        const head = snake[0];
        
        // Check wall collision
        if (
            head.x < 0 || 
            head.x >= canvas.width || 
            head.y < 0 || 
            head.y >= canvas.height
        ) {
            return true;
        }
        
        // Check self collision
        for (let i = 1; i < snake.length; i++) {
            if (head.x === snake[i].x && head.y === snake[i].y) {
                return true;
            }
        }
        
        return false;
    }
    
    // Create trail effect
    function createTrail(x, y) {
        const trail = document.createElement('div');
        trail.className = 'trail';
        trail.style.width = `${gridSize}px`;
        trail.style.height = `${gridSize}px`;
        trail.style.left = `${x}px`;
        trail.style.top = `${y}px`;
        
        trailContainer.appendChild(trail);
        
        // Animate trail
        gsap.to(trail, {
            opacity: 0,
            scale: 1.5,
            duration: 0.5,
            onComplete: () => trail.remove()
        });
    }
    
    // Update game speed based on score and difficulty
    function updateGameSpeed() {
        // Base speed adjustment
        let speedAdjustment = Math.max(50, gameSpeed - Math.floor(score / 50) * 5);
        
        // Apply difficulty multiplier
        if (difficulty === 'easy') {
            gameSpeed = Math.max(150, speedAdjustment);
        } else if (difficulty === 'medium') {
            gameSpeed = Math.max(100, speedAdjustment);
        } else if (difficulty === 'hard') {
            gameSpeed = Math.max(70, speedAdjustment);
        }
        
        // Update game interval
        if (isGameRunning) {
            clearInterval(gameInterval);
            gameInterval = setInterval(moveSnake, gameSpeed);
        }
    }
    
    // Game over
    function gameOver() {
        isGameRunning = false;
        clearInterval(gameInterval);
        
        // Check for high score
        const isNewHighScore = score > highScore;
        if (isNewHighScore) {
            highScore = score;
            localStorage.setItem('snakeHighScore', highScore);
            highScoreElement.textContent = highScore;
            newHighScoreElement.classList.remove('hidden');
        } else {
            newHighScoreElement.classList.add('hidden');
        }
        
        // Show final score
        finalScoreElement.textContent = score;
        
        // Show game over screen with animation
        gsap.fromTo(gameOverScreen,
            { opacity: 0, scale: 0.8 },
            { opacity: 1, scale: 1, duration: 0.3, onComplete: () => gameOverScreen.classList.remove('hidden') }
        );
    }
    
    // Start game
    function startGame() {
        isGameRunning = true;
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        
        // Set game speed based on difficulty
        if (difficulty === 'easy') {
            gameSpeed = 200;
        } else if (difficulty === 'medium') {
            gameSpeed = 150;
        } else if (difficulty === 'hard') {
            gameSpeed = 100;
        }
        
        // Initialize and start game loop
        initGame();
        gameInterval = setInterval(moveSnake, gameSpeed);
    }
    
    // Cycle through difficulties
    function cycleDifficulty() {
        if (difficulty === 'easy') {
            difficulty = 'medium';
            difficultyText.textContent = 'Medium';
        } else if (difficulty === 'medium') {
            difficulty = 'hard';
            difficultyText.textContent = 'Hard';
        } else {
            difficulty = 'easy';
            difficultyText.textContent = 'Easy';
        }
    }
    
    // Handle key presses
    function handleKeyPress(e) {
        if (!isGameRunning) return;
        
        switch (e.key) {
            case 'ArrowRight':
                if (direction !== 'left') nextDirection = 'right';
                break;
            case 'ArrowLeft':
                if (direction !== 'right') nextDirection = 'left';
                break;
            case 'ArrowUp':
                if (direction !== 'down') nextDirection = 'up';
                break;
            case 'ArrowDown':
                if (direction !== 'up') nextDirection = 'down';
                break;
        }
    }
    
    // Handle touch gestures for mobile
    let touchStartX, touchStartY;
    
    function handleTouchStart(e) {
        if (!isGameRunning) return;
        
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        e.preventDefault();
    }
    
    function handleTouchMove(e) {
        if (!isGameRunning || !touchStartX || !touchStartY) return;
        
        const touchEndX = e.touches[0].clientX;
        const touchEndY = e.touches[0].clientY;
        
        const dx = touchEndX - touchStartX;
        const dy = touchEndY - touchStartY;
        
        // Determine direction based on largest movement
        if (Math.abs(dx) > Math.abs(dy)) {
            // Horizontal swipe
            if (dx > 0 && direction !== 'left') {
                nextDirection = 'right';
            } else if (dx < 0 && direction !== 'right') {
                nextDirection = 'left';
            }
        } else {
            // Vertical swipe
            if (dy > 0 && direction !== 'up') {
                nextDirection = 'down';
            } else if (dy < 0 && direction !== 'down') {
                nextDirection = 'up';
            }
        }
        
        // Reset touch positions
        touchStartX = touchEndX;
        touchStartY = touchEndY;
        
        e.preventDefault();
    }
    
    // Event Listeners
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('keydown', handleKeyPress);
    canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
    canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    
    // Button Event Listeners
    startBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', startGame);
    homeBtn.addEventListener('click', () => {
        gameOverScreen.classList.add('hidden');
        startScreen.classList.remove('hidden');
    });
    difficultyBtn.addEventListener('click', cycleDifficulty);
    
    // Mobile Control Buttons
    document.getElementById('upBtn').addEventListener('click', () => {
        if (direction !== 'down') nextDirection = 'up';
    });
    document.getElementById('leftBtn').addEventListener('click', () => {
        if (direction !== 'right') nextDirection = 'left';
    });
    document.getElementById('rightBtn').addEventListener('click', () => {
        if (direction !== 'left') nextDirection = 'right';
    });
    document.getElementById('downBtn').addEventListener('click', () => {
        if (direction !== 'up') nextDirection = 'down';
    });
    
    // Initialize
    resizeCanvas();
    initGame();
    
    // Add animation to start screen
    gsap.fromTo(startScreen.children,
        { y: 20, opacity: 0 },
        { y: 0, opacity: 1, stagger: 0.1, duration: 0.5 }
    );
</script>
</html>